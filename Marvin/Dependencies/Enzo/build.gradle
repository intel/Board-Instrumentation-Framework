/*
 * Copyright (c) 2015 by Gerrit Grunwald
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Enzo main build file
import java.text.SimpleDateFormat

/* Updated by Patrick Kutch to accommodate Java 11 */
plugins {
    id 'java-library'
    id 'org.openjfx.javafxplugin' version '0.0.13'
    id 'idea'
    id 'signing'
}

sourceCompatibility = '11'
version = 'Enzo-0.3.6a' // Manually specified project version

wrapper {
    gradleVersion = '7.6'
}

repositories {
    mavenCentral()
}

apply plugin: 'idea'
apply plugin: 'signing'

// Apply settings for signing if available
if (file("signing.properties").exists()) {
    Properties props = new Properties()
    props.load(new FileInputStream("signing.properties"))
    props.each { key, value -> project.ext[key] = value }
}

javafx {
    version = "11"
    modules = [ 'javafx.controls' ]
}

subprojects.each { subproject ->
    evaluationDependsOn(subproject.path)
}

Date buildTimeAndDate = new Date()
ext {
    buildDate = new SimpleDateFormat('yyyy-MM-dd').format(buildTimeAndDate)
    buildTime = new SimpleDateFormat('HH:mm:ss.SSSZ').format(buildTimeAndDate)
}

dependencies {
    implementation 'com.googlecode.json-simple:json-simple:1.1.1'
}

// create one jar for the library
tasks.register('oneJar', Jar) {
    dependsOn subprojects.findAll { it.plugins.hasPlugin('java') }.collect { it.tasks.jar }

    subprojects.findAll { it.plugins.hasPlugin('java') }.each { subproject ->
        from zipTree(subproject.tasks.jar.archiveFile.get())
    }

    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    manifest {
        attributes(
            'Built-By': System.properties['user.name'],
            'Created-By': System.properties['java.version'] + " (" + System.properties['java.vendor'] + " " + System.properties['java.vm.version'] + ")",
            'Build-Date': project.buildDate,
            'Build-Time': project.buildTime,
            'Specification-Title': project.name,
            'Specification-Version': project.version,
            'Implementation-Title': project.name,
            'Implementation-Version': project.version,
            'Bundle-Name': project.name,
            'Bundle-License': 'https://www.apache.org/licenses/LICENSE-2.0',
            'Bundle-Description': 'Enzo widgets',
            'Bundle-SymbolicName': 'eu.hansolo.enzo',
            'Automatic-Module-Name': 'eu.hansolo.enzo'
        )
    }

    archiveFileName = "${version}.jar"
}

// create one jar for the javadoc
tasks.register('docs', Javadoc) {
    source subprojects.collect { project -> project.sourceSets.main.allJava }
    classpath = files(subprojects.collect { project -> project.sourceSets.main.compileClasspath })
    destinationDir = new File('build/docs/javadoc')
}
// create one jar for the javadoc
tasks.register('javadocJar', Jar) {
    // Ensure the Javadocs are generated for all subprojects
    dependsOn subprojects.findAll { it.plugins.hasPlugin('java') }.collect { it.tasks.javadoc }

    // Include the Javadoc files from each subproject
    subprojects.findAll { it.plugins.hasPlugin('java') }.each { subproject ->
        from subproject.tasks.javadoc.destinationDir
    }

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE // Handle duplicate entries

    classifier = 'javadoc'
    archiveFileName = "javadoc-${version}.jar"
}

// create one jar for the source files
tasks.register('sourcesJar', Jar) {
    // Ensure the source JARs are created for all subprojects
    dependsOn subprojects.findAll { it.plugins.hasPlugin('java') }.collect { it.tasks.jar }

    // Include the source files from each subproject
    subprojects.findAll { it.plugins.hasPlugin('java') }.each { subproject ->
        from subproject.sourceSets.main.allSource
    }

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE // Handle duplicate entries

    classifier = 'sources'
    archiveFileName = "sources-${version}.jar"
}

artifacts {
    archives tasks.oneJar
    archives tasks.javadocJar
    archives tasks.sourcesJar
}

// signing the artifacts
if (hasProperty('release')) {
    signing {
        sign configurations.archives
    }
}
